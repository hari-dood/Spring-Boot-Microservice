Stream<T> sorted()
Stream<T> sorted(Comparator<? super T> comparator)


import java.util.*;
import java.util.stream.*;

class ProductPurchaseRequest {
    private int productId;
    private int quantity;

    public ProductPurchaseRequest(int productId, int quantity) {
        this.productId = productId;
        this.quantity = quantity;
    }

    public int getProductId() {
        return productId;
    }

    public int getQuantity() {
        return quantity;
    }

    @Override
    public String toString() {
        return "Product ID: " + productId + ", Quantity: " + quantity;
    }
}

public class ProductSortExample {
    public static void main(String[] args) {
        List<ProductPurchaseRequest> requestList = Arrays.asList(
                new ProductPurchaseRequest(3, 10),
                new ProductPurchaseRequest(1, 5),
                new ProductPurchaseRequest(2, 20)
        );

        // Sort by productId using sorted with a Comparator
        var sortedRequest = requestList.stream()
                                      .sorted(Comparator.comparing(ProductPurchaseRequest::getProductId))
                                      .collect(Collectors.toList());

        sortedRequest.forEach(System.out::println); // Print sorted requests
    }
}


Product ID: 1, Quantity: 5
Product ID: 2, Quantity: 20
Product ID: 3, Quantity: 10

1.Strings: The natural order for strings is lexicographical (alphabetical order).


List<String> words = Arrays.asList("banana", "apple", "cherry");
var sortedWords = words.stream()
                       .sorted()
                       .collect(Collectors.toList());
sortedWords.forEach(System.out::println); // Prints: apple, banana, cherry

Integers: For numeric types (like Integer, Double, Long, etc.), you can sort them in ascending or descending order.

List<Integer> numbers = Arrays.asList(10, 5, 8, 1, 3);
var sortedNumbers = numbers.stream()
                           .sorted()
                           .collect(Collectors.toList());
sortedNumbers.forEach(System.out::println); // Prints: 1, 3, 5, 8, 10


Custom Objects: You can sort custom objects by any field in the object, such as productId, name, price, etc. This can be done with Comparator.comparing().

class Product {
    private String name;
    private double price;

    public Product(String name, double price) {
        this.name = name;
        this.price = price;
    }

    public double getPrice() {
        return price;
    }

    @Override
    public String toString() {
        return "Product{name='" + name + "', price=" + price + '}';
    }
}

List<Product> products = Arrays.asList(
    new Product("Laptop", 1000.00),
    new Product("Phone", 700.00),
    new Product("Tablet", 300.00)
);

var sortedProducts = products.stream()
                             .sorted(Comparator.comparing(Product::getPrice))
                             .collect(Collectors.toList());

sortedProducts.forEach(System.out::println);


DSA Concept:
In Data Structures and Algorithms (DSA), sorting is an essential concept. Sorting helps in organizing data in a specific order, making it easier to search, process, and analyze. Here's an overview:

Sorting Algorithms: In DSA, sorting is typically done using various algorithms like:

Bubble Sort: Simple but inefficient for large datasets.
Selection Sort: Finds the minimum element and places it in the correct position.
Insertion Sort: Builds the sorted list one item at a time.
Merge Sort: Divide and conquer approach, splitting the data into smaller parts and merging them back together.
Quick Sort: A fast divide-and-conquer algorithm based on partitioning the array into smaller elements.
Heap Sort: Uses a binary heap to sort data.
Complexity: Sorting algorithms have different time complexities:

Bubble Sort, Selection Sort, and Insertion Sort: O(n²)
Merge Sort and Quick Sort (average case): O(n log n)
Heap Sort: O(n log n)
Real-World Applications:

Sorting is crucial in tasks like searching, ranking, and categorizing data. It’s used in databases, search engines, e-commerce sites, and more.
By understanding how sorting works in both simple examples and complex algorithms, you can optimize your applications and improve data management. The Stream.sorted() method simplifies sorting when working with Java collections, making it a useful tool in everyday programming.